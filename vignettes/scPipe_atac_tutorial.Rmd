---
title: "scPipe: a flexible data preprocessing pipeline for single-cell data"
author: "Shani Amarasinghe"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{scPipe: flexible data preprocessing pipeline for single-cell data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

`scPipe` is a package initially designed to process single-cell RNA-sequencing (scRNA-seq) data generated by different protocols. We have modified it to accommodate pre-processing capability of single-cell ATAC-Seq (Assay for Transposase-Accessible Chromatin using sequencing) data preprocessing. scPipe ATAC-Seq module is designed for protocols without UMIs, but can also adapt to any UMI protocols. 
%todo: think about adjusting below.
`scPipe` consist of two major components. The first is data preprocessing with raw fastq as input and a gene count matrix as output. The second component starts from the gene count matrix, includes quality control and a shiny app for clustering and visualization.

# Case Study: Preprocessing 10X scATAC-Seq data

`10X ATAC` method currently is the most popular method to generate scATAC-Seq data with higher sensitivity and lower cost. The structure of the 10X ATAC library is shown below. 

The output fastq files from a `10X ATAC` experiment is paired-ended and data is contained within both reads.

## Getting started

It is not mandatory to specify an output folder even thoug it can be specified. If no `output_folder` is defined a folder named `scPipe-atac-output`will get created in the working directory.

We begin by loading the library.

```{r, message=FALSE}
library(scPipe)
library(SingleCellExperiment)
```

## Organising the files required

To process the data, we need the genome fasta file, a bed format of the features (which can be generated in a later step) and a cell barcode annotation. The barcode annotation could be either in a `.fastq` format or a `.csv` file with at least two columns, where the first column has the cell id and the second column contains the barcode sequence. All these files can be found in the `data` folder of the `scPipe` package:

```{r}
# file path:
reference          <- here("data", "genome.fa")
features           <- here("data", "extdata", "NA_peaks.narrowPeak")
barcode_fastq      <- here("data","testfastq_S1_L001_R2_001.fastq.gz") 
```

The read structure for this example is paired-end, with the first longer read mapping to transcripts and second shorter read consisting of 6bp UMIs followed by 8bp cell barcodes. **NOTE**: by convention, `scPipe` always assumes `read1` refers to the read with the transcript sequence, which is usually the longer read. These data are also available in the in `extdata` folder:

```{r,eval=TRUE}
r1      <- here("data","testfastq_S1_L001_R1_001.fastq.gz") 
r2      <- here("data","testfastq_S1_L001_R3_001.fastq.gz") 
```

## Data Preprocessing

### Fastq reformatting

The pipeline starts with fastq file reformatting. We move the barcode and UMI sequences (if available) to the read name and leave the transcript sequence as is. This outputs a read name that looks like `@[barcode_sequence]_[UMI_sequence]#[readname]` ... Usually the scATAC-Seq data is paired end and a 16bp long barcode is located on both reads. Here the barcode information is located on a seperate fastq file and the length of the barcode fastq file matches the length of the reads files. Therefore, you need a miniaml example like below to generate the output.

```{r,eval=TRUE}
sc_atac_trim_barcode (r1            = r1, 
                      r2            = r2, 
                      bc_file       = barcode_fastq, 
                      rmN           = TRUE,
                      rmlow         = TRUE,
                      output_folder = "")
```

This generates two output files that are appended by the prefix `demux_` to notify that the new files are the reformated (a.k.a. demultiplexed) `.fastq` files. These will get saved in the `scPipe-atac-output` directory if the user has not specified an `output_folder`.

However, if the barcodes are in the form of a `.csv` file, an extra information on barcode start and the barcode length is also required to be entered by the user. The algorithms is flexible to do a "look-around" to identify whether the correct parameters are used for a subset of data (hence saving time) and report back to the console if it believes the barcode position is incorrect and/or should be shifted.

This process will output three different outputs depending on the findings;
* complete matches: When the barcode is completely matched and identified in the correct position
* partial methes: When the barcode is identified in the location specified but corrected with hamming ditance approach
* unmatched: no barcode match is found in the given position even after hamming distance corrections are applied

```{r,eval=FALSE}
sc_atac_trim_barcode (r1            = r1_barcode, 
                      r2            = r2_barcode, 
                      bc_file       = barcode_1000, 
                      bc_start      = 3, 
                      bc_length     = 16, 
                      output_folder = "", 
                      rmN           = TRUE)
```

**NOTE**: we use a zero based index system, so the indexing of the sequence starts at zero.

### Aligning reads to a reference genome

Next, we align reads to the genome. This example uses `Rsubread` but any aligner that support RNA-seq alignment and gives standard BAM output can be used here.

```{r,eval=TRUE}

demux_r1        <- here("scPipe-atac-output", "demux_testfastq_S1_L001_R1_001.fastq.gz")
demux_r2        <- here("scPipe-atac-output", "demux_testfastq_S1_L001_R3_001.fastq.gz")

sc_atac_aligning(ref       = reference, 
                 readFile1 = demux_r1, 
                 readFile2 = demux_r2, 
                 nthreads  = 6)
```

### Demultiplexing the BAM file

Next, the BAM file needs to be modified in a way one or two new columns are generated for the cell barcode tag and the molecular barcode (i.e. UMI) tag denoted by `CB:Z:` and `OX:Z:`, respectively.

```{r, eval=TRUE}
bam_to_tag  <- here("scPipe-atac-output", "demux_testfastq_S1_L001_R1_001_aligned.bam")

sc_atac_bam_tagging (inbam         = bam_to_tag, 
                     output_folder =  "", 
                     bam_tags      = list(bc="CB", mb="OX"), 
                     nthreads      =  6)
```

### Identifying features

% for Phil to complete

### Assigning reads to features and feature counting

After the read alignment and generating an array of features, we assign reads to these features using the `sc_atac_feature_counting` function.

```{r,eval=TRUE}
sorted_tagged_bam <- here("scPipe-atac-output","demux_testfastq_S1_L001_R1_001_aligned_tagged_sorted.bam")
features          <- here("data", "extdata", "NA_peaks.narrowPeak")

sc_atac_feature_counting (insortedbam   = sorted_tagged_bam,
                          feature_input = features, 
                          bam_tags      = list(bc="CB", mb="OX"), 
                          feature_type  = "peak", 
                          organism      = "hg38",
                          cell_calling  = FALSE,
                          genome_size   = NULL,
                          bin_size      = NULL, 
                          qc_per_bc_file= NULL,
                          yieldsize     = 1000000,
                          mapq          = 20,
                          exclude_regions = TRUE,
                          output_folder = "",
                          fix_chr       = "none"
                          )
```

This generates a matrix format of the feature by cell matrix that can be used downstream to generate a `singleCellExperiment, SCE` object.

```{r,eval=FALSE}
feature_matrix <- readRDS(here("scPipe-atac-output", "feature_matrix.rds"))
str(feature_matrix)

sparseM <- readMM(here("scPipe-atac-output", "sparse_matrix.mtx"))
str(sparseM)
```

We have now completed the preprocessing steps. The feature count matrix is available as a `.rds` file in `scPipe-atac-output/feature_matrix.rds` and quality control statistics are saved in the `scPipe-atac-output/scPipe_atac_stats` folder. These data are useful for later quality control (QC).


# Preprocessing data generated by other protocols



## Quality Control

The easiest way to create a *SingleCellExperiment* object from the output of `scPipe` preprocessing is using `create_sce_by_dir` function, that will read in the feature count matrix together with the QC information available in the `scPipe_atac_stats` folder.

```{r}
sc_atac_create_sce()
```

The dataset we analysed above used ERCC simulated reads from 10 cells of perfect quality. In order to demonstrate QC on a more reaslitic example, we have included an experimental dataset in the `scPipe` software generated by Dr Christine Biben. This experiment profiles gene expression in 383 blood cells for a subset of 1000 genes (to save space). We first create a *SingleCellExperiment* object directly without using the `create_sce_by_dir` function:

```{r}
data("sc_sample_data")
data("sc_sample_qc")
sce = SingleCellExperiment(assays = list(counts = as.matrix(sc_sample_data))) # generate new sce with gene count matrix
QC_metrics(sce) = sc_sample_qc
demultiplex_info(sce) = cell_barcode_matching
UMI_dup_info(sce) = UMI_duplication
```

There are several plots we can create to assess the overall quality of the experiment. The first is to look at the cell barcode demultiplexing statistics. To do this we generate a bar plot that shows the percentage of reads that uniquely match to the cell barcodes, as well as the unmatched proportion of reads and their alignment rates to introns and exons. If we observe a large proportion of unmatched reads that map to exons, this indicates a failure of the cell barcode demultiplexing.

```{r, fig.height=7, fig.width=7}
plot_demultiplex(sce)
```

A second plot shows the duplication rate which can be used to evaluate read depth. UMIs are routinely used to mark individual molecules and after PCR amplification, the same molecule with have multiple copys, which can be identified and removed if they are observed to have the same UMI sequence. Therefore, the copy number of UMIs is an indication of the PCR amplification rate. 

```{r, fig.height=7, fig.width=7}
plot_UMI_dup(sce)
```

Next we calculate QC metrics and use the `detect_outlier` function to identify poor quality cells. The `detect_outlier` function has argument `comp` to define the maximum component of the gaussian mixture model. Using the default value of 1 is generally sufficient, but in cases where the data are heterogeneous in terms of quality control metrics, setting this value to 2 or 3 can give better results. This function will remove low quality cells if `type="low"`, large cells if `type="high"` or both when `type="both"`. The `conf` argument specifies the lower and upper confidence intervals for outliers and `detect_outlier` is insensistive to the interval values.

```{r, warning=FALSE, message=FALSE}
sce = calculate_QC_metrics(sce)
sce = detect_outlier(sce)
```

We can plot the alignment statistics per sample as a barplot using

```{r, fig.height=7, fig.width=7}
plot_mapping(sce, percentage = TRUE, dataname = "sc_sample_data")
```

and generate pairwise plots of the QC metrics as follows:

```{r, warning=FALSE, message=FALSE, fig.height=7, fig.width=7}
plot_QC_pairs(sce)
```

The final step will be to remove the low quality cells by the `remove_outliers` function. 

```{r}
sce = remove_outliers(sce)
dim(sce)
```

# Downstream analysis

Since the **scater** and **scran** packages both use the *SingleCellExperiment* class, it will be easy to further process this data using these packages for normalization and visualization. Other packages such as **SC3** may be useful for clustering and **MAST** and **edgeR** for differential expression analysis.

```{r}
sessionInfo()
```
